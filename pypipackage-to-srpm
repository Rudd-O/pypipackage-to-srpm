#!/usr/bin/env python

from __future__ import print_function

import argparse
import contextlib
import glob
import os
import shutil
import subprocess
import sys
import tarfile
import tempfile


sys.path.append(os.path.dirname(__file__))


import pypipackagetosrpmmod as mod


@contextlib.contextmanager
def tmpdir(keeptemp=False):
  d = tempfile.mkdtemp()
  try:
    yield d
  finally:
    if not keeptemp:
      shutil.rmtree(d)


def mangle_specfile(path, requires, buildrequires, skip_mangling_name, patches):
  unmangled_name = None
  mangled_name = None
  names_defined = False
  lines = open(path, "r").readlines()
  for n, line in enumerate(lines[:]):
    if line.startswith("%define name "):
      unmangled_name = line[len("%define name "):]
      mangled_name = unmangled_name if skip_mangling_name else mod.mangle_name(unmangled_name)
      lines[n] = "%define unmangled_name " + unmangled_name + "%define mangled_name " + mangled_name 
    elif line.startswith("%define release "):
      if "%{?dist}" not in line:
        lines[n] = "%define release " + line[len("%define release "):-1] + "%{?dist}" + "\n"
    elif line.startswith("Name: "):
      lines[n] = lines[n].replace("%{name}", "%{mangled_name}")
      if requires:
        requires = "Requires: %s\n" % ", ".join(requires)
        lines[n] = lines[n] + requires
      if buildrequires:
        buildrequires = "BuildRequires: %s\n" % ", ".join(buildrequires)
        lines[n] = lines[n] + buildrequires
      names_defined = True
    elif line.startswith("Source") and patches:
        extralines = []
        for patchn, patch in enumerate(patches):
            line = line + "Patch%d: %s\n" % (patchn, os.path.basename(patch))
        lines[n] = line
    elif line.startswith("%setup") and patches:
      for patchn, _ in enumerate(patches):
        line = line + "%%patch%d\n" % patchn
      lines[n] = line
    if names_defined:
      lines[n] = lines[n].replace("%{name}", "%{unmangled_name}")
  out = open(path, "w")
  out.write("".join(lines))
  out.flush()
  out.close()

def run(cmd, cwd=None, stdin=None):
  p = subprocess.Popen(cmd, cwd=cwd, stdin=stdin, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
  stdout, _ = p.communicate()
  ret = p.wait()
  ret = ret == 0
  return ret, stdout


def remove_spaces_in_first_component(tarfile_path, newtarfile_path):
    tar = tarfile.open(tarfile_path, "r:gz")
    newtar = tarfile.open(newtarfile_path, "w:gz")
    for tarinfo in tar:
        oldcomps = tarinfo.name
        comps = tarinfo.name.split(os.path.sep)
        comps[0] = comps[0].replace(" ", "")
        tarinfo.name = os.path.sep.join(comps)
        newtar.addfile(tarinfo, tar.extractfile(tarinfo))
    tar.close()
    newtar.close()
    return newtarfile_path


def package(path, outputdir, keeptemp, skip_mangling_name=False, patches=None):
  patches = [] if patches is None else patches
  if not os.path.isdir(outputdir):
    raise ValueError("%r must be a directory and must exist" % outputdir)
  with tmpdir(keeptemp) as td:
    if keeptemp:
      print("Temporary work directory:", td)
    if path.endswith(".tar.gz"):
      success, output = run(["tar", "-zx", "-C", td, "-f", path])
      if not success:
        print("Error uncompressing:\n", output, file=sys.stderr)
        return 8
    elif path.endswith(".zip"):
      success, output = run(["unzip", "-d", td, path])
      if not success:
        print("Error uncompressing:\n", output, file=sys.stderr)
        return 8
    else:
      assert 0, "Do not know how to handle file type of %r" % path
    sourcepath = glob.glob(os.path.join(td, "*"))[0]
    if " " in sourcepath:
        new_sourcepath = sourcepath.replace(" ", "")
        print("Renaming %s to %s" % (sourcepath, new_sourcepath), file=sys.stderr)
        os.rename(sourcepath, new_sourcepath)
        sourcepath = new_sourcepath
        del new_sourcepath
    for patch in patches:
        pf = open(patch)
        success, output = run(['patch', '-p0'], cwd=sourcepath, stdin=pf)
        if not success:
          print("Error in patching %s:\n" % patch, file=sys.stderr)
          print(output.decode("utf-8", errors="ignore"), file=sys.stderr)
          return 10
    success, output = run([sys.executable, "setup.py", "bdist_rpm"], cwd=sourcepath)
    if not success:
      print("Error in bdist_rpm:", file=sys.stderr)
      print(output.decode("utf-8", errors="ignore"), file=sys.stderr)
      return 10
    try:
        requiresfile = glob.glob(os.path.join(td, "*", "*.egg-info", "requires.txt"))[0]
        orgrequires = open(requiresfile).readlines()
        requires = mod.gen_requires(orgrequires)
    except IndexError:
        orgrequires = []
        requires = []
    print("Original requires: %s" % orgrequires, file=sys.stderr)
    print("Requires: %s" % requires, file=sys.stderr)
    success, findcfiles = run(["find", td, "-name", "*.c", "-print0"])
    if not success:
      print("Error in finding C files:", file=sys.stderr)
      print(output.decode("utf-8", errors="ignore"), file=sys.stderr)
      return 10
    if findcfiles:
      buildrequires = ["python%s-devel" % (sys.version_info.major, )]
    else:
      buildrequires = []
    print("BuildRequires: %s" % buildrequires, file=sys.stderr)
    sourcerpm = glob.glob(os.path.join(td, "*", "dist", "*.src.rpm"))[0]
    def rpm(*args):
      return run(["rpm", "--define", "%%_topdir %s/RPM" % td] + list(args))
    def rpmbuild(*args):
      return run(["rpmbuild", "--define", "%%_topdir %s/RPM" % td] + list(args))
    success, output = rpm("-ivh", sourcerpm)
    if not success:
      print("Error installing distutils source RPM:\n%s" % (output, ), file=sys.stderr)
      return 12
    specfile = glob.glob(os.path.join(td, "RPM", "SPECS", "*.spec"))[0]
    for patch in patches:
        shutil.copyfile(patch, os.path.join(td, "RPM", "SOURCES", os.path.basename(patch)))
    remove_spaces_in_first_component(path, os.path.join(td, "RPM", "SOURCES", os.path.basename(path)))
    mangle_specfile(specfile, requires, buildrequires, skip_mangling_name, patches)
    success, output = rpmbuild("-bs", specfile)
    if not success:
      print("Error constructing final source RPM:\n", output, file=sys.stderr)
      return 14
    srpm = glob.glob(os.path.join(td, "RPM", "SRPMS", "*.src.rpm"))[0]
    success, output = rpmbuild("--rebuild", srpm)
    if not success:
      print("Error rebuilding final source RPM:", file=sys.stderr)
      print(output, file=sys.stderr)
      return 16
    brpm = glob.glob(os.path.join(td, "RPM", "RPMS", "*", "*.rpm"))[0]
    success, output = rpm("-qp", "--provides", brpm)
    print("Package %s provides:" % os.path.basename(brpm), file=sys.stderr)
    for line in output.splitlines(False):
      print("*", line, file=sys.stderr)
    success, output = rpm("-qp", "--requires", brpm)
    print("Package %s requires:" % os.path.basename(brpm), file=sys.stderr)
    for line in output.splitlines(False):
      print("*", line, file=sys.stderr)
    destfile = os.path.join(outputdir, os.path.basename(srpm))
    if os.path.exists(destfile):
      print("Error: not replacing %r" % destfile, file=sys.stderr)
      return 18
    shutil.move(srpm, destfile)

def main():
  parser = argparse.ArgumentParser(description="Turn downloaded PyPI packages into source RPMs")
  parser.add_argument('--outputdir',
    dest="outputdir",
    help="Output directory to store the source RPMs into (must exist, default: current directory)",
    action="store",
    default=os.path.curdir,
  )
  parser.add_argument('--keeptemp',
    dest="keeptemp",
    help="Print and keep the temporary work directory",
    action="store_true",
    default=False,
  )
  parser.add_argument('--no-mangle-name',
    dest="nomanglename",
    help="Avoid mangling the package name",
    action="store_true",
    default=False,
  )
  parser.add_argument('source',
    metavar="SOURCE",
    type=str,
    nargs=1,
    help="Source tarball, zip file or wheel",
  )
  parser.add_argument('patches',
    metavar="PATCHES",
    type=str,
    nargs='*',
    help="Plain text diff-formatted patches",
  )
  args = parser.parse_args()
  ret = package(args.source[0], args.outputdir, args.keeptemp, args.nomanglename, args.patches)
  if ret:
    sys.exit(ret)

if __name__ == "__main__":
  os.environ["http_proxy"] = "http://127.0.0.1:1"
  os.environ["https_proxy"] = "http://127.0.0.1:1"
  main()
